Memory Management and Memory Addressing:

Each process has seperate physical memory space. >> [This helps in concurrent execution.]
To maintain the concurrency, process need to access legal addresses.
Address protection is managed by two registers "Base & Limit"
	Base:  Smallest legal physical memory address.
	Limit: Specifies the size of the range.
	---------------------
	Base Register: 300040
	Limit Register: 120900

	Final address = Base Register + Limit Register.

	Final address = 300040 + 120900
	Final address = 420940
	----------------------
Process can access all addresses between [300040 - 420940].

Protection of memory space is accomplished by having a "CPU hardware compare"
every address generated in user mode to access OS memory or other user's memory 
results in a trap to the OS.

-------------------------------------------------------------------------------
[root@hguptaVM C-concepts]# cat /proc/4691/maps
00400000-00401000 r-xp 00000000 fd:02 70439782                           /home/Algorithms/a.out
00600000-00601000 r--p 00000000 fd:02 70439782                           /home/Algorithms/a.out
00601000-00602000 rw-p 00001000 fd:02 70439782                           /home/Algorithms/a.out
0138f000-013b0000 rw-p 00000000 00:00 0                                  [heap]
7f17f14ff000-7f17f16b8000 r-xp 00000000 fd:00 148445                     /usr/lib64/libc-2.28.so
7f17f16b8000-7f17f18b8000 ---p 001b9000 fd:00 148445                     /usr/lib64/libc-2.28.so
7f17f18b8000-7f17f18bc000 r--p 001b9000 fd:00 148445                     /usr/lib64/libc-2.28.so
7f17f18bc000-7f17f18be000 rw-p 001bd000 fd:00 148445                     /usr/lib64/libc-2.28.so
7f17f18be000-7f17f18c2000 rw-p 00000000 00:00 0
7f17f18c2000-7f17f18ea000 r-xp 00000000 fd:00 148428                     /usr/lib64/ld-2.28.so
7f17f1ad6000-7f17f1ad8000 rw-p 00000000 00:00 0
7f17f1aea000-7f17f1aeb000 r--p 00028000 fd:00 148428                     /usr/lib64/ld-2.28.so
7f17f1aeb000-7f17f1aec000 rw-p 00029000 fd:00 148428                     /usr/lib64/ld-2.28.so
7f17f1aec000-7f17f1aed000 rw-p 00000000 00:00 0
7ffde59fa000-7ffde5a1b000 rw-p 00000000 00:00 0                          [stack]
7ffde5b39000-7ffde5b3c000 r--p 00000000 00:00 0                          [vvar]
7ffde5b3c000-7ffde5b3e000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
-------------------------------------------------------------------------------

Address Binding:
|---------------|

Program resides on the disk as a binary executable file. 
To run, program must be brought into the memory & placed in the context of a 
process, where it becomes eligible for execution.

Binding of instructions and data to memory addresses can be done at various 
stages:

1. COMPILE TIME: 
	If you know at the compile time where the process will reside in memory,
	then absolute code can be generated.
2. LOAD TIME: 
	If it is not known at compile time where the process will reside in 
	memory, then compiler should generate relocatable code.
	In this case final binding is delayed until load time.
3. EXECUATION TIME:
	If the process can be moved during its execution from one memory segment
	to another, then binding must be delayed till run time.

		    logical		    physical
		    address		    address
	|--------|		|--------|		|-----------|
	|  CPU 	 |  ------->	|  MMU   | ------->	| Physical  |
	|--------|		|--------|		| Memory    |
							|           |
							|-----------|
Binding addresses at either compile or load time generates identical logical
and physical addresses. However, the execution-time address-binding scheme
results in differing logical and physical addresses.

The run-time mapping from virtual to physical addresses is done by a
hardware device called the memory-management unit (MMU)

The base register is now called a relocation register. The value in the 
relocation register is added to every
address generated by a user process at the time the address is sent to memory
(see Figure 9.5). For example, if the base is at 14000, then an attempt by the
user to address location 0 is dynamically relocated to location 14000; an access
to location 346 is mapped to location 14346.
The user program never accesses the real physical addresses. The program
can create a pointer to location 346, store it in memory, manipulate it, and 
compare it with other addresses—all as the number 346. Only when it is used as a
memory address (in an indirect load or store, perhaps) is it relocated 
relative to the base register.

We now have two different types of addresses: logical addresses (in the
range 0 to max) and physical addresses (in the range R + 0 to R + max for a base
value R). The user program generates only logical addresses and thinks that
the process runs in memory locations from 0 to max. However, these logical
addresses must be mapped to physical addresses before they are used.

DYNAMIC LOADING:
A routine is not loaded until it is called. All routines are kept on disk
in a relocatable load format. The main program is loaded into memory and
is executed. When a routine needs to call another routine, the calling routine
first checks to see whether the other routine has been loaded. If it has not, 
the relocatable linking loader is called to load the desired routine into 
memory and to update the program’s address tables to reflect this change. 
Then control is passed to the newly loaded routine.

ADVANTAGE OF DYNAMIC LOADING:
The advantage of dynamic loading is that a routine is loaded only when it
is needed. This method is particularly useful when large amounts of code are
needed to handle infrequently occurring cases, such as error routines. In such
a situation, although the total program size may be large, the portion that is
used (and hence loaded) may be much smaller.

Dynamic Linking and Shared Libraries:

Dynamic linking, in contrast, is similar to dynamic loading.
Here, though, linking, rather than loading, is postponed until execution time.
This feature is usually used with system libraries, such as the standard C
language library.Without this facility, each program on a system must include a
copy of its language library (or at least the routines referenced by the program)
in the executable image. This requirement not only increases the size of an
executable image but also may waste main memory.
------------------------------------------------
A second advantage of DLLs is that these libraries can be shared among multiple
processes, so that only one instance of the DLL in main memory.
For this reason, DLLs are also known as shared libraries.
